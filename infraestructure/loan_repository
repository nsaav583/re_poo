from infraestructure.connection import Connection
from models.book import Book
from models.user import User
from models.loan import Loan

class LoanRepository:
    def __init__(self, conn: Connection) -> None:
        self.__conn = conn

    #metodo para prestar un libro, recibiendo un usuario y un libro, extrayendo de ambos información
    def loan_book(self, book: Book, user: User) -> Loan:
        if self.is_available(book.get_id()): 
            sql = "INSERT INTO loan (user_name, user_id, book_title, book_isbn) VALUES (%s, %s, %s, %s)"
            self.__conn.execute(sql, (
                user.get_name(),
                user.get_id(),
                book.get_title(),
                book.get_isbn()
            ))
            self.__conn.commit()
            # Actualizar disponibilidad del libro en la base de datos, en proceso
            sql_update = "UPDATE book SET is_available = 0 WHERE id = %s"
            self.__conn.execute(sql_update, (book.get_id()))
            self.__conn.commit()
            print(f"Prestamo realizado con exito, ahora el usuario: {user.get_name()} tiene el libro: {book.get_title()}")
            return Loan
        else:          
            print("El libro no se encuentra disponible")
            return None

    #metodo para ver si un libro esta disponible en la BD, en proceso
    def is_available(self, book_id: int) -> bool:    
        sql = "SELECT is_available FROM book WHERE id = %s"
        self.__conn.execute(sql, (book_id))
        result = self.__conn.fetchone()
        return result
    
    def return_book(self, loan_id: int, book: Book):
        try:
            sql = "DELETE FROM loan WHERE loan_id = %s" 
            self.__conn.execute(sql, (loan_id))
            self.__conn.commit()

            sql_update = "UPDATE book SET is_available = 1 WHERE id = %s" 
            self.__conn.execute(sql_update, (book.get_id()))
            
            self.__conn.commit()
            print(f"El libro '{book.get_title()}' ha sido devuelto.")
        except Exception as e:
            #self.__conn.rollback() #ver porque no funciona
            print(f"Error al registrar la devolución: {e}")

    #en proceso
    def show_loans(self):
        """Muestra todos los préstamos activos"""
        self.cursor.execute("""
            SELECT loans.loan_id, books.title, users.name
            FROM loans
            JOIN books ON loans.book_id = books.book_id
            JOIN users ON loans.user_id = users.user_id
        """)
        loans = self.cursor.fetchall()
        if not loans:
            print("No hay préstamos activos.")
        else:
            for loan in loans:
                print(f"Préstamo ID: {loan[0]}, Libro: '{loan[1]}', Usuario: {loan[2]}")

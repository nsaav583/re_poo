from infraestructure.connection import Connection
from models.book import Book
from models.user import User
from models.loan import Loan

class LoanRepository:
    def __init__(self, conn: Connection) -> None:
        self.__conn = conn
    #metodo para prestar un libro, recibiendo un usuario y un libro, extrayendo de ambos información (este fue modificado)
    def loan_book(self, book: Book, user: User) -> Loan:
        if self.is_available(book.get_id()): 
            try:
            # Iniciar la transacción de préstamo
                sql = "INSERT INTO loan (user_name, user_id, book_title, book_isbn) VALUES (%s, %s, %s, %s)"
                self.__conn.execute(sql, (
                    user.get_name(),
                    user.get_id(),
                    book.get_title(),
                    book.get_isbn()
                    ))
                self.__conn.commit()
                sql_update = "UPDATE libros SET is_available = 0 WHERE id = %s"
                self.__conn.execute(sql_update, (book.get_id(),))
                self.__conn.commit()
                print(f"Préstamo realizado con éxito, ahora el usuario: {user.get_name()} tiene el libro: {book.get_title()}")
            # Crear una instancia de Loan y usar los setters
                loan = Loan()
                loan.set_user(user)  # Asignamos el objeto User
                loan.set_book(book)  # Asignamos el objeto Book
            # Si deseas establecer también el ID del préstamo, puedes hacerlo después de obtenerlo de la base de datos:
            # Suponiendo que el ID del préstamo se autoincremente en la tabla 'loan' y se puede recuperar
                return loan
            except Exception as e:
            # Si hay algún error, se hace un rollback de la transacción
                print(f"Error al procesar el préstamo: {e}")
                return None
        else:          
            print("El libro no se encuentra disponible")
            return None

    #metodo para ver si un libro esta disponible en la BD, en proceso (este tambien se modificó)

    def is_available(self, book_id: int) -> bool:
        sql = "SELECT is_available FROM libros WHERE id = %s"
        self.__conn.execute(sql, (book_id,))
        result = self.__conn.fetchone()
        if result and result[0] == 1:  # verificamos que 'is_available' sea 1 (disponible)
            return True
        else:
            return False
    
    def return_book(self, loan_id: int, book: Book):
        try:
            sql = "DELETE FROM loan WHERE loan_id = %s" 
            self.__conn.execute(sql, (loan_id))
            self.__conn.commit()

            sql_update = "UPDATE book SET is_available = 1 WHERE id = %s" 
            self.__conn.execute(sql_update, (book.get_id()))
            
            self.__conn.commit()
            print(f"El libro '{book.get_title()}' ha sido devuelto.")
        except Exception as e:
            #self.__conn.rollback() #ver porque no funciona
            print(f"Error al registrar la devolución: {e}")

    #en proceso
    def show_loans(self):
        """Muestra todos los préstamos activos"""
        self.cursor.execute("""
            SELECT loans.loan_id, books.title, users.name
            FROM loans
            JOIN books ON loans.book_id = books.book_id
            JOIN users ON loans.user_id = users.user_id
        """)
        loans = self.cursor.fetchall()
        if not loans:
            print("No hay préstamos activos.")
        else:
            for loan in loans:
                print(f"Préstamo ID: {loan[0]}, Libro: '{loan[1]}', Usuario: {loan[2]}")
